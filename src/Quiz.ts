
import { AccountUpdate, assert, Bool, Experimental, Field, method, Poseidon, PrivateKey, PublicKey, SmartContract, state, State, Struct, UInt64 } from 'o1js';
class PauseToggleEvent extends Struct({ was_paused: Bool, is_paused: Bool }) {}
export const adminKey = PrivateKey.random();
export class WinnerState extends Struct({
    amount: UInt64,
    isPaid: Bool,
    finishDate: UInt64
}) {}

export class QuizState extends Struct({
    duration: UInt64,
    startDate: UInt64,
    secretKey: Field
}) {}

const { OffchainState } = Experimental;
export const offchainState = OffchainState(
    {
        winners: OffchainState.Map(PublicKey, WinnerState),
        quizState: OffchainState.Field(QuizState),
        
    },
    { logTotalCapacity: 10, maxActionsPerProof: 5}
);
export class StateProof extends offchainState.Proof { }

export class Quiz extends SmartContract {
    @state(OffchainState.Commitments) offchainStateCommitments = offchainState.emptyCommitments();
    @state(PublicKey) admin = State<PublicKey>();
    offchainState = offchainState.init(this);


    init() {
        super.init();
        this.admin.set(adminKey.toPublicKey());
    }


    @method async initQuizState(
        secretKey: Field,
        duration: UInt64,
        startDate: UInt64,
        totalRewardPoolAmount: UInt64 // This is the total reward pool
    ) {
        this.sender.getAndRequireSignature().assertEquals(this.admin.getAndRequireEquals());
        this.offchainState.fields.quizState.overwrite({secretKey, duration, startDate});
        await this.deposit(this.sender.getAndRequireSignature(), totalRewardPoolAmount);
    }

    /**
 * Settles settlement proof
 *
 * @param proof - StateProof generated by the Offchain State ZkProgram
 */
    @method
    async settle(proof: StateProof) {
        this.sender.getAndRequireSignature().assertEquals(this.admin.getAndRequireEquals());
        await this.offchainState.settle(proof);
    }

    async deposit(user: PublicKey, amount: UInt64) {
        // add your deposit logic circuit here
        // that will adjust the amount

        const payerUpdate = AccountUpdate.createSigned(user);
        payerUpdate.send({ to: this.address, amount: amount });
    }

    @method async checkIsOver() {
        const quizState = (await this.offchainState.fields.quizState.get()).assertSome("Quiz state not found");
        const durations = quizState.duration
        const startDate = quizState.startDate
        const endDate = startDate.add(durations)

        const timestamps = this.network.timestamp.getAndRequireEquals()

        timestamps.assertGreaterThanOrEqual(endDate)
    }

    @method async checkIsContinue() {
        const quizState = (await this.offchainState.fields.quizState.get()).assertSome("Quiz state not found");
        const durations = quizState.duration
        const startDate = quizState.startDate
        const endDate = startDate.add(durations)

        this.network.timestamp.requireBetween(startDate, endDate)
    }

    // I want to send to 3 users at one payout call and I will call this function in batches
    // I will send the nullifier tree and the nullifier to the function to control if the three user batch used before
    @method async payoutByThree(
        winner1: PublicKey,
        winner2: PublicKey,
        winner3: PublicKey
    ) {
        this.sender.getAndRequireSignature().assertEquals(this.admin.getAndRequireEquals());
        await this.checkIsOver();
        const balance = this.account.balance.getAndRequireEquals();
        const winner1State = (await this.offchainState.fields.winners.get(winner1)).assertSome("Winner1 not found");
        const winner2State = (await this.offchainState.fields.winners.get(winner2)).assertSome("Winner2 not found");
        const winner3State = (await this.offchainState.fields.winners.get(winner3)).assertSome("Winner3 not found");
        assert(winner1State.isPaid.not(), "winner1 already paid");
        assert(winner2State.isPaid.not(), "winner2 already paid");
        assert(winner3State.isPaid.not(), "winner3 already paid");
        const reward1 = winner1State.amount
        const reward2 = winner2State.amount
        const reward3 = winner3State.amount
        assert(balance.greaterThanOrEqual(reward1.add(reward2).add(reward3)), "balance must be greater than 0");
        // finally, we send the payouts
        this.send({ to: winner1, amount: reward1 });
        this.send({ to: winner2, amount: reward2 });
        this.send({ to: winner3, amount: reward3 });
        this.offchainState.fields.winners.update(winner1, { from: winner1State, to: { ...winner1State, isPaid: Bool(true) } });
        this.offchainState.fields.winners.update(winner2, { from: winner2State, to: { ...winner2State, isPaid: Bool(true) } });
        this.offchainState.fields.winners.update(winner3, { from: winner3State, to: { ...winner3State, isPaid: Bool(true) } });
    }
}